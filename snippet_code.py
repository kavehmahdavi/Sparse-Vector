#!/usr/bin/env python3.6
# -*- coding: utf-8 -*-

"""
It is a part of a parser code that takes input data (frequently financial text pages), extracts the data, and builds a
data structure. Probably, the text pages are generated by optical character recognition (OCR) software by scanning the
printed invoice.
In particular, those functions are built to identify the currency,  invoice cumulative information, tax ID,
phone number, and postal code through the text.
"""

import json
import pandas as pd
import re
import itertools
import operator

pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)

"""
CURRENCY_CODING = {
    "USD": {"name": "usd", "symbol": "$"},
    "EUR": {"name": "eur", "symbol": "€"},
    "GBP": {"name": "gbp", "symbol": "£"},
    "NZD": {"name": "nzd", "symbol": "$"},
}
"""

CURRENCY_CODING = {
    "NZD": {"name": "nzd", "symbol": "NZ$"},
    "USD": {"name": "usd", "symbol": "$"},
    "EUR": {"name": "eur", "symbol": "€"},
    "GBP": {"name": "gbp", "symbol": "£"},
}


def currency_parser(text_pages):
    currency_count_dict = {}
    text_currencies_df = pd.DataFrame()
    if len(text_pages) > 0:
        #text_currencies_df.loc[:, "text"] = pd.Series(text_pages).str.lower()
        text_pages = text_pages.lower()
        text_currencies_df.loc[:, "text"] = pd.Series(text_pages)
        for currency in CURRENCY_CODING:
            # text_currencies_df.loc[:, (currency + "_symbol")] = text_currencies_df["text"].str.contains(CURRENCY_CODING[currency]["symbol"], regex=False)
            if currency == 'USD':
                text_currencies_df.loc[:, (currency + "_symbol")] = len(re.findall('\$', text_pages))
                text_currencies_df.loc[:, (currency + "_symbol")]= text_currencies_df.loc[:, (currency + "_symbol")] - text_currencies_df.loc[:, ("NZD_symbol")]
            elif currency == 'NZD':
                text_currencies_df.loc[:, (currency + "_symbol")] = len(re.findall('nz\$', text_pages))
            else:
                text_currencies_df.loc[:, (currency + "_symbol")] = len(re.findall(CURRENCY_CODING[currency]["symbol"], text_pages))

            # text_currencies_df.loc[:, (currency + "_name")] = text_currencies_df["text"].str.contains(CURRENCY_CODING[currency]["name"], regex=False)
            text_currencies_df.loc[:, (currency + "_name")] = len(re.findall(CURRENCY_CODING[currency]["name"], text_pages))

            # text_currencies_df.loc[:, currency] = text_currencies_df[(currency + "_symbol")].astype(int) + text_currencies_df[(currency + "_name")].astype(int)
            text_currencies_df.loc[:, currency] = text_currencies_df[(currency + "_symbol")] + text_currencies_df[(currency + "_name")]

            currency_count = text_currencies_df[currency].sum()
            if currency_count > 0:
                currency_count_dict[currency] = currency_count

    top_currency = None
    if currency_count_dict:
        #top_currency = max(currency_count_dict.items(), key=operator.itemgetter(1))[0]
        top_currency = [key for key, value in currency_count_dict.items() if value == max(currency_count_dict.values())]
    return top_currency


def predict_amount_fields_from_ocr_data(text_pages):
    amount_list = []
    """
    for text in text_pages:
        text = text.replace(",", ""))
    """
    text = text_pages.replace(",", "")

    str_list = re.findall(r"[+-]?[0-9]+\.[0-9]{2}", text)
    float_list = [float(x) for x in str_list]
    amount_list.append(float_list)

    combinations_list = []
    amount_list = list(itertools.chain.from_iterable(amount_list))
    unique_list = sorted(list(set(amount_list)))
    last_index = len(unique_list)
    index_list = list(range(last_index))
    for index_value_1 in index_list:
        for index_value_2 in index_list:
            if index_value_2 > index_value_1:
                float_1 = unique_list[index_value_1]
                float_2 = unique_list[index_value_2]
                subtotal = float_2 - float_1
                if subtotal in amount_list:
                    combination_dict = {
                        "SubTotal": subtotal,
                        "TotalTax": float_1,
                        "InvoiceTotal": float_2
                    }
                    combinations_list.append(combination_dict)
    best_combination_dict = {
        "SubTotal": None,
        "TotalTax": None,
        "InvoiceTotal": None,
        "TaxPerc": None
    }
    if len(combinations_list) > 0:
        combinations_df = pd.DataFrame(combinations_list)
        combinations_df.loc[:, "TaxPerc"] = 100. * combinations_df["TotalTax"] / combinations_df["SubTotal"]
        percentage_cond1 = combinations_df["TaxPerc"] >= 0.0
        percentage_cond2 = combinations_df["TaxPerc"] < 25.0

        # integer_tax_cond = 100 * combinations_df["TaxPerc"] == (100. * combinations_df["TaxPerc"]).astype(int)
        #filtered_combinations_df = combinations_df[percentage_cond1 & percentage_cond2 & integer_tax_cond ]
        filtered_combinations_df = combinations_df[percentage_cond1 & percentage_cond2]

        if not filtered_combinations_df.empty:
            best_combination_dict = filtered_combinations_df.sort_values(by=["TaxPerc", "InvoiceTotal"],
                                                                         ascending=[True, False]).iloc[0].to_dict()
    return best_combination_dict


def extract_phone_number_from_lines(text_pages):
    if text_pages is None:
        raise Exception

    # lines = list(itertools.chain.from_iterable(text_pages))
    lines = text_pages.split()

    #
    _phone_list = []
    for line in lines:
        #match = re.search(re.compile(r"\s\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})\s"), line)
        match = re.search(re.compile(r"\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})"), line)
        if match:
            span = match.span()
            #return line[span[0]: span[1]].strip()
            _phone_list.append(line[span[0]: span[1]].strip())
    #return ""
    return _phone_list


def vendor_tax_id_us_parser(text_pages):
    if text_pages is None:
        raise Exception
    #lines = list(itertools.chain.from_iterable(text_pages))
    lines = text_pages.split()

    matches = []
    for line in lines:
        #match = re.search(re.compile(r"\s[0-9]{2}-[0-9]{7}\s"), line)
        match = re.search(re.compile(r"[0-9]{2}-[0-9]{7}"), line)
        if match:
            span = match.span()
            matches.append(line[span[0]: span[1]].strip())
    if not matches:
        extract = None
    else:
        extract = json.dumps(matches)
    return extract


def postal_code_us_parser(text_pages):
    if text_pages is None:
        raise Exception
    #output = ""
    output=[]
    #lines = list(itertools.chain.from_iterable(text_pages))
    lines = text_pages.split()
    for line in lines:
        #match = re.search(re.compile(r"\s[0-9]{5}(?:-[0-9]{4})?\s"), line)
        match = re.search(re.compile(r"[0-9]{5}(?:-[0-9]{4})?"), line)
        if match:
            span = match.span()
            #output = line[span[0]: span[1]].strip()
            output.append(line[span[0]: span[1]].strip())
    return output


if __name__ == '__main__':
    print(currency_parser(" $12.4 , Euro 3453.6  €125 £8955.2 $-1,234,567.89 usd57811 NZ$44566" ))
    print(predict_amount_fields_from_ocr_data("8.00 1.00 9.00"))
    print(extract_phone_number_from_lines("(556)-236-2235\n 556-235-2235\n 232-352-4452"))
    print(vendor_tax_id_us_parser("22-3453453 \n 54-5684925"))
    print(postal_code_us_parser("45546-5454"))
